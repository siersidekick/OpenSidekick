<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SidekickOS BLE Frame Streamer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .status-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .connection-status {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 15px;
            border-radius: 25px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .status-indicator.connected {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .status-indicator.disconnected {
            background: linear-gradient(45deg, #f44336, #d32f2f);
            color: white;
        }

        .status-indicator.partial {
            background: linear-gradient(45deg, #ff9800, #f57c00);
            color: white;
        }

        .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .control-panel h3 {
            margin-bottom: 20px;
            color: #333;
            font-size: 1.3rem;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .button:active {
            transform: translateY(0);
        }

        .button.danger {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }

        .button.success {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }

        .button.warning {
            background: linear-gradient(45deg, #ff9800, #f57c00);
        }

        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .media-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        .frame-display {
            position: relative;
            width: 100%;
            max-width: 640px;
            margin: 0 auto 20px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            background: #f0f0f0;
        }

        .frame-display img {
            width: 100%;
            height: auto;
            display: block;
        }

        .frame-placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 240px;
            color: #666;
            font-size: 1.1rem;
        }

        .frame-info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8rem;
        }

        .audio-section {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }

        .audio-visualizer {
            width: 100%;
            height: 80px;
            background: #333;
            border-radius: 5px;
            margin: 15px 0;
            position: relative;
            overflow: hidden;
        }

        .audio-bars {
            display: flex;
            align-items: end;
            height: 100%;
            padding: 5px;
            gap: 2px;
        }

        .audio-bar {
            flex: 1;
            background: linear-gradient(to top, #4CAF50, #8BC34A);
            border-radius: 2px;
            transition: height 0.1s ease;
            min-height: 2px;
        }

        .settings-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .log-container {
            background: #1a1a1a;
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            z-index: 1000;
            transform: translateX(100%);
            transition: transform 0.3s ease;
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }

        .notification.error {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }

        .notification.warning {
            background: linear-gradient(45deg, #ff9800, #f57c00);
        }

        .pyscript-panel {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-top: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        }

        .code-editor {
            width: 100%;
            height: 200px;
            font-family: 'Courier New', monospace;
            background: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            resize: vertical;
        }

        .app-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .app-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .app-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
        }

        .app-card h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .app-card p {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 10px;
        }

        .app-actions {
            display: flex;
            gap: 10px;
        }

        .app-actions button {
            padding: 6px 12px;
            font-size: 0.8rem;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #ddd;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .connection-status {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 1.8rem;
            }

            .settings-panel {
                grid-template-columns: 1fr;
            }
        }

        .perf-row {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }

        .perf-row span {
            flex: 1;
            text-align: left;
        }

        #performanceInfo {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
        }

        #performanceStats {
            font-family: 'Courier New', monospace;
        }
    </style>
    <link rel="stylesheet" href="https://pyscript.net/releases/2024.1.1/core.css">
    <script type="module" src="https://pyscript.net/releases/2024.1.1/core.js"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 SidekickOS BLE Ultra-Speed Camera & Audio</h1>
            <p>BLE 5.0 + Data Length Extension + 510-byte chunks + 7.5ms intervals</p>
            <div style="background: linear-gradient(45deg, #ff6b6b, #feca57); color: white; padding: 8px 16px; border-radius: 20px; font-weight: bold; margin-top: 10px; display: inline-block;">
                ⚡ ULTRA PERFORMANCE MODE ⚡
            </div>
        </div>

        <div class="status-card">
            <div class="connection-status">
                <div class="status-indicator disconnected" id="bleStatus">
                    <div class="dot"></div>
                    <span>BLE Disconnected</span>
                </div>
                <div class="status-indicator disconnected" id="audioStatus">
                    <div class="dot"></div>
                    <span>Audio Not Streaming</span>
                </div>
                <div class="status-indicator" id="deviceInfo">
                    <span>Battery: -- | Memory: --</span>
                </div>
                <div class="status-indicator" id="performanceInfo">
                    <div style="font-weight: bold; margin-bottom: 5px;">🚀 Ultra-Speed Performance Statistics</div>
                    <div id="performanceStats" style="font-size: 0.9em;">
                        <div class="perf-row">
                            <span>Image: 0.0 kbps (Target: 400-600+)</span>
                            <span>Audio: 0.0 kbps</span>
                        </div>
                        <div class="perf-row">
                            <span>Avg Image: 0.0 kbps</span>
                            <span>FPS: 0.0 (Target: 25-50)</span>
                        </div>
                        <div class="perf-row">
                            <span>Total: 0.0 kbps</span>
                            <span>Frames: 0</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                <button class="button" id="connectBLEBtn" onclick="connectBLE()">Connect BLE Device</button>
                <button class="button warning" onclick="scanForDevices()">Scan for Devices</button>
                <button class="button danger" id="disconnectBtn" onclick="disconnect()" disabled>Disconnect</button>
                <button class="button" onclick="requestStatus()">Refresh Status</button>
            </div>
        </div>

        <div class="controls-grid">
            <div class="control-panel">
                <h3>Frame Streaming</h3>
                <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
                    <button class="button success" id="startFramesBtn" onclick="startFrameStream()" disabled>Start Frames</button>
                    <button class="button danger" id="stopFramesBtn" onclick="stopFrameStream()" disabled>Stop Frames</button>
                    <button class="button" onclick="captureImage()" disabled id="captureBtn">Capture Photo</button>
                </div>
                
                <div class="settings-panel">
                    <div class="input-group">
                        <label>Frame Interval (0.05-10s)</label>
                        <input type="range" min="0.05" max="10" step="0.05" value="0.5" id="intervalSlider" onchange="updateInterval(this.value)">
                        <span id="intervalValue">0.5s</span>
                    </div>
                    
                    <div class="input-group">
                        <label>Image Quality (4-63)</label>
                        <input type="range" min="4" max="63" value="15" id="qualitySlider" onchange="updateQuality(this.value)">
                        <span id="qualityValue">15</span>
                    </div>
                    
                    <div class="input-group">
                        <label>Frame Size</label>
                        <select id="frameSizeSelect" onchange="updateFrameSize(this.value)">
                            <option value="0">96x96 (Tiny)</option>
                            <option value="1" selected>QQVGA (160x120)</option>
                            <option value="2">QVGA (320x240)</option>
                            <option value="3">CIF (352x288)</option>
                            <option value="4">VGA (640x480)</option>
                            <option value="5">HVGA (480x320)</option>
                            <option value="6">SVGA (800x600)</option>
                            <option value="7">XGA (1024x768)</option>
                            <option value="8">SXGA (1280x1024)</option>
                            <option value="9">UXGA (1600x1200)</option>
                        </select>
                    </div>
                    
                    <div class="input-group">
                        <label>
                            <input type="checkbox" id="performanceMode" onchange="togglePerformanceMode(this.checked)">
                            High Performance Mode (20 FPS target)
                        </label>
                    </div>
                    
                    <div class="input-group">
                        <button class="button warning" id="ultraModeBtn" onclick="toggleUltraMode()" disabled style="width: 100%; background: linear-gradient(45deg, #ff6b6b, #feca57);">
                            🚀 ULTRA MODE (50 FPS)
                        </button>
                    </div>
                </div>
            </div>

            <div class="control-panel">
                <h3>BLE Audio Streaming</h3>
                <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
                    <button class="button success" id="startAudioBtn" onclick="startAudioStream()" disabled>Start Audio</button>
                    <button class="button danger" id="stopAudioBtn" onclick="stopAudioStream()" disabled>Stop Audio</button>
                </div>
                
                <div class="input-group">
                    <label>Volume</label>
                    <input type="range" min="0" max="100" value="50" id="volumeSlider" onchange="updateVolume(this.value)">
                    <span id="volumeValue">50%</span>
                </div>
                
                <div class="audio-section">
                    <div id="audioConnectionStatus">Connect BLE to enable audio</div>
                    <div class="audio-visualizer" id="audioVisualizer" style="display: none;">
                        <div class="audio-bars" id="audioBars">
                            <!-- Audio bars will be generated here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="media-container">
            <h3>Live Frames</h3>
            <div class="frame-display" id="frameDisplay">
                <div class="frame-placeholder" id="framePlaceholder">
                    Connect to SidekickOS to see live frames
                </div>
                <div class="frame-info" id="frameInfo" style="display: none;">
                    Frame: -- | Size: --
                </div>
            </div>
            
            <div style="display: flex; gap: 15px; flex-wrap: wrap; justify-content: center;">
                <button class="button" onclick="saveCurrentFrame()" disabled id="saveFrameBtn">Save Current Frame</button>
                <button class="button" onclick="toggleFullscreen()">Toggle Fullscreen</button>
            </div>

            <div class="progress-bar" id="imageProgress" style="display: none;">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>

        <div class="pyscript-panel">
            <h3>PyScript Applications</h3>
            <p>Create custom applications using Python that interact with the SidekickOS frame streamer:</p>
            
            <div class="input-group">
                <label>Application Name</label>
                <input type="text" id="appName" placeholder="My Frame App">
            </div>
            
            <div class="input-group">
                <label>Python Code</label>
                <textarea class="code-editor" id="pythonCode" placeholder="# Available functions:
# - esp32_api.capture_image()
# - esp32_api.start_frames()
# - esp32_api.stop_frames()
# - esp32_api.set_interval(seconds)
# - esp32_api.set_quality(value)
# - esp32_api.get_status()
# - esp32_api.start_audio()
# - esp32_api.stop_audio()

# Example motion detection app:
import asyncio
from js import esp32_api, console, document

async def motion_detector():
    console.log('Starting motion detector...')
    
    # Start frame streaming
    await esp32_api.start_frames()
    await esp32_api.set_interval(1)  # 1 second intervals
    
    console.log('Motion detector active!')

motion_detector()"></textarea>
            </div>
            
            <div style="display: flex; gap: 15px; margin-bottom: 20px;">
                <button class="button success" onclick="saveApp()">Save Application</button>
                <button class="button" onclick="runPyScript()">Run Code</button>
                <button class="button danger" onclick="clearCode()">Clear</button>
            </div>
            
            <h4>Saved Applications</h4>
            <div class="app-list" id="appList">
                <!-- Saved apps will appear here -->
            </div>
        </div>

        <div class="log-container" id="logContainer">
            <div>🚀 SidekickOS Ultra-Speed Frame Streamer Log</div>
            <div>⚡ BLE 5.0 + DLE + 510-byte chunks + 7.5ms intervals ready</div>
            <div>🎯 Target: 400-600+ kbps, 25-50 FPS performance</div>
            <div>Ready to connect...</div>
        </div>
    </div>

    <div id="notification" class="notification"></div>

    <!-- PyScript Section -->
    <py-script>
import asyncio
from js import document, console, esp32_api
from pyodide.ffi import create_proxy

class ESP32API:
    def __init__(self):
        self.device_connected = False
        
    async def capture_image(self):
        if hasattr(esp32_api, 'captureImage'):
            return await esp32_api.captureImage()
        else:
            console.log("ESP32 API not available")
            
    async def start_frames(self):
        if hasattr(esp32_api, 'startFrameStream'):
            return await esp32_api.startFrameStream()
        else:
            console.log("ESP32 API not available")
            
    async def stop_frames(self):
        if hasattr(esp32_api, 'stopFrameStream'):
            return await esp32_api.stopFrameStream()
        else:
            console.log("ESP32 API not available")
            
    async def set_interval(self, seconds):
        if hasattr(esp32_api, 'setInterval'):
            return await esp32_api.setInterval(seconds)
        else:
            console.log("ESP32 API not available")
            
    async def set_quality(self, value):
        if hasattr(esp32_api, 'setQuality'):
            return await esp32_api.setQuality(value)
        else:
            console.log("ESP32 API not available")
            
    async def start_audio(self):
        if hasattr(esp32_api, 'startAudioStream'):
            return await esp32_api.startAudioStream()
        else:
            console.log("ESP32 API not available")
            
    async def stop_audio(self):
        if hasattr(esp32_api, 'stopAudioStream'):
            return await esp32_api.stopAudioStream()
        else:
            console.log("ESP32 API not available")
            
    async def get_status(self):
        if hasattr(esp32_api, 'getStatus'):
            return await esp32_api.getStatus()
        else:
            console.log("ESP32 API not available")
            return {}

# Make ESP32 API available globally for user scripts
esp32_api_instance = ESP32API()

def execute_user_code(code):
    try:
        globals_dict = {
            '__builtins__': __builtins__,
            'esp32_api': esp32_api_instance,
            'console': console,
            'asyncio': asyncio,
            'document': document
        }
        exec(code, globals_dict)
        console.log("User code executed successfully")
    except Exception as e:
        console.error(f"Error executing user code: {e}")

# Expose function to JavaScript
js_execute_user_code = create_proxy(execute_user_code)
document.pyExecuteUserCode = js_execute_user_code
    </py-script>

    <script>
        // BLE Configuration
        // TEMPORARY: Use 16-bit UUID for testing
        const BLE_SERVICE_UUID = '00001234-0000-1000-8000-00805f9b34fb';
        const CONTROL_CHAR_UUID = '87654321-4321-4321-4321-cba987654321';
        const STATUS_CHAR_UUID = '11111111-2222-3333-4444-555555555555';
        const IMAGE_CHAR_UUID = '22222222-3333-4444-5555-666666666666';
        const FRAME_CONTROL_CHAR_UUID = '44444444-5555-6666-7777-888888888888';
        const AUDIO_CHAR_UUID = '33333333-4444-5555-6666-777777777777';  // Added missing audio UUID

        // Global variables
        let bleDevice = null;
        let bleServer = null;
        let controlCharacteristic = null;
        let statusCharacteristic = null;
        let imageCharacteristic = null;
        let frameControlCharacteristic = null;
        let audioCharacteristic = null;  // Added for BLE audio
        
        let isBLEConnected = false;
        let isAudioStreaming = false;  // Changed from isAudioConnected
        let deviceStatus = {};
        let currentFrame = null;
        let frameCount = 0;
        
        // Image reception variables
        let imageBuffer = null;
        let expectedImageSize = 0;
        let receivedImageSize = 0;
        let isReceivingFrame = false;
        let receivedChunks = 0;
        let expectedChunks = 0;
        let imageTimeout = null;
        
        // Audio variables
        let audioContext = null;
        let audioVisualizerBars = [];
        let audioGainNode = null;
        let audioQueue = [];  // Queue for incoming audio packets
        
        // Application storage
        let savedApps = JSON.parse(localStorage.getItem('esp32_frame_apps') || '[]');

        // G.711 μ-law decoding table
        const mulaw_decode_table = new Int16Array([
            -32124, -31100, -30076, -29052, -28028, -27004, -25980, -24956,
            -23932, -22908, -21884, -20860, -19836, -18812, -17788, -16764,
            -15996, -15484, -14972, -14460, -13948, -13436, -12924, -12412,
            -11900, -11388, -10876, -10364, -9852, -9340, -8828, -8316,
            -7932, -7676, -7420, -7164, -6908, -6652, -6396, -6140,
            -5884, -5628, -5372, -5116, -4860, -4604, -4348, -4092,
            -3900, -3772, -3644, -3516, -3388, -3260, -3132, -3004,
            -2876, -2748, -2620, -2492, -2364, -2236, -2108, -1980,
            -1884, -1820, -1756, -1692, -1628, -1564, -1500, -1436,
            -1372, -1308, -1244, -1180, -1116, -1052, -988, -924,
            -876, -844, -812, -780, -748, -716, -684, -652,
            -620, -588, -556, -524, -492, -460, -428, -396,
            -372, -356, -340, -324, -308, -292, -276, -260,
            -244, -228, -212, -196, -180, -164, -148, -132,
            -120, -112, -104, -96, -88, -80, -72, -64,
            -56, -48, -40, -32, -24, -16, -8, 0,
            32124, 31100, 30076, 29052, 28028, 27004, 25980, 24956,
            23932, 22908, 21884, 20860, 19836, 18812, 17788, 16764,
            15996, 15484, 14972, 14460, 13948, 13436, 12924, 12412,
            11900, 11388, 10876, 10364, 9852, 9340, 8828, 8316,
            7932, 7676, 7420, 7164, 6908, 6652, 6396, 6140,
            5884, 5628, 5372, 5116, 4860, 4604, 4348, 4092,
            3900, 3772, 3644, 3516, 3388, 3260, 3132, 3004,
            2876, 2748, 2620, 2492, 2364, 2236, 2108, 1980,
            1884, 1820, 1756, 1692, 1628, 1564, 1500, 1436,
            1372, 1308, 1244, 1180, 1116, 1052, 988, 924,
            876, 844, 812, 780, 748, 716, 684, 652,
            620, 588, 556, 524, 492, 460, 428, 396,
            372, 356, 340, 324, 308, 292, 276, 260,
            244, 228, 212, 196, 180, 164, 148, 132,
            120, 112, 104, 96, 88, 80, 72, 64,
            56, 48, 40, 32, 24, 16, 8, 0
        ]);

        // Decode μ-law to 16-bit linear PCM
        function mulaw_decode(mulaw_byte) {
            return mulaw_decode_table[mulaw_byte];
        }

        async function scanForDevices() {
            try {
                log('Scanning for BLE devices...');
                showNotification('Scanning for devices...', 'warning');
                
                const device = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true,
                    optionalServices: [BLE_SERVICE_UUID, '0000180f-0000-1000-8000-00805f9b34fb'] // Battery service for debugging
                });
                
                log(`Found device: ${device.name || 'Unnamed'} (ID: ${device.id})`);
                
                if (device.name && device.name.includes('ESP32')) {
                    log('Found ESP32 device! This looks promising.');
                    showNotification(`Found: ${device.name}`, 'success');
                } else {
                    log('This device might not be the SidekickOS. Look for "SidekickOS" in the list.');
                    showNotification(`Found: ${device.name || 'Unnamed device'}`, 'warning');
                }
                
            } catch (error) {
                log('Device scan failed: ' + error.message);
                showNotification('Scan cancelled or failed', 'error');
            }
        }

        // Diagnostic function
        async function checkBLEStatus() {
            log('=== BLE Diagnostic Information ===');
            
            if (!navigator.bluetooth) {
                log('❌ Web Bluetooth not supported in this browser');
                showNotification('Web Bluetooth not supported. Use Chrome, Edge, or Opera.', 'error');
                return;
            }
            
            log('✅ Web Bluetooth is supported');
            
            try {
                const availability = await navigator.bluetooth.getAvailability();
                log(`Bluetooth availability: ${availability}`);
                
                if (!availability) {
                    log('❌ Bluetooth is not available on this device');
                    showNotification('Bluetooth is not available. Check your system settings.', 'error');
                    return;
                }
                
                log('✅ Bluetooth is available');
                log('✅ Ready to scan for SidekickOS');
                
            } catch (error) {
                log('Error checking Bluetooth availability: ' + error.message);
            }
        }

        // Initialize diagnostics on load
        document.addEventListener('DOMContentLoaded', function() {
            loadSavedApps();
            initializeAudio();
            createAudioVisualizer();
            checkBLEStatus(); // Add diagnostic check
            
            // Check for Web Bluetooth support
            if (!navigator.bluetooth) {
                showNotification('Web Bluetooth is not supported in this browser', 'error');
                document.getElementById('connectBLEBtn').disabled = true;
            }
        });

        // BLE Connection Functions
        async function connectBLE() {
            try {
                log('Requesting BLE device...');
                
                // Try multiple discovery methods
                const requestOptions = {
                    // First try by service UUID
                    filters: [
                        { services: [BLE_SERVICE_UUID] },
                        { name: "SidekickOS" },
                        { namePrefix: "SidekickOS" }
                    ],
                    optionalServices: [BLE_SERVICE_UUID]
                };

                // Fallback to accept all devices if specific filtering fails
                try {
                    bleDevice = await navigator.bluetooth.requestDevice(requestOptions);
                } catch (firstError) {
                    log('First discovery method failed, trying broader search...');
                    bleDevice = await navigator.bluetooth.requestDevice({
                        acceptAllDevices: true,
                        optionalServices: [BLE_SERVICE_UUID]
                    });
                }
                
                // Clear any cached services
                if (bleDevice.gatt && bleDevice.gatt.connected) {
                    log('Disconnecting to clear cache...');
                    bleDevice.gatt.disconnect();
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                log(`Found device: ${bleDevice.name || 'Unknown'} (${bleDevice.id})`);
                log('Connecting to GATT server...');
                bleServer = await bleDevice.gatt.connect();
                
                // Wait for connection to stabilize
                log('Waiting for connection to stabilize...');
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Log MTU information for Data Length Extension (DLE)
                if (bleServer.mtu) {
                    log(`📡 MTU: ${bleServer.mtu} bytes (DLE ${bleServer.mtu > 23 ? 'ENABLED' : 'DISABLED'})`);
                    if (bleServer.mtu >= 517) {
                        log(`🚀 ULTRA-SPEED MODE: Maximum 517-byte MTU detected!`);
                    }
                } else {
                    log(`📡 MTU: Checking for BLE 5.0 DLE support...`);
                }
                
                // === NEW: DISCOVER ALL SERVICES FOR DEBUGGING ===
                log('=== DISCOVERING ALL SERVICES ===');
                try {
                    // Try multiple discovery methods
                    log('Method 1: getPrimaryServices() without filter');
                    const services = await bleServer.getPrimaryServices();
                    log(`Found ${services.length} services:`);
                    
                    for (let i = 0; i < services.length; i++) {
                        const service = services[i];
                        log(`Service ${i + 1}: UUID = ${service.uuid}`);
                        
                        // Check if this matches our target UUID
                        if (service.uuid === BLE_SERVICE_UUID || service.uuid.toLowerCase() === BLE_SERVICE_UUID.toLowerCase()) {
                            log(`🎯 FOUND OUR TARGET SERVICE! UUID = ${service.uuid}`);
                        }
                        
                        // Try to get characteristics for each service
                        try {
                            const characteristics = await service.getCharacteristics();
                            log(`  - Has ${characteristics.length} characteristics`);
                            for (let j = 0; j < characteristics.length; j++) {
                                log(`    Char ${j + 1}: ${characteristics[j].uuid}`);
                            }
                        } catch (charError) {
                            log(`  - Could not read characteristics: ${charError.message}`);
                        }
                    }
                    
                    // Method 2: Try to get our specific service directly
                    log(`Method 2: Trying to get service ${BLE_SERVICE_UUID} directly`);
                    try {
                        const ourService = await bleServer.getPrimaryService(BLE_SERVICE_UUID);
                        log(`✅ SUCCESS: Found our service directly! UUID = ${ourService.uuid}`);
                    } catch (directError) {
                        log(`❌ FAILED: Could not get our service directly: ${directError.message}`);
                    }
                    
                } catch (serviceError) {
                    log('Failed to discover services: ' + serviceError.message);
                    
                    // Try alternative discovery method
                    log('Trying alternative service discovery...');
                    try {
                        const ourService = await bleServer.getPrimaryService(BLE_SERVICE_UUID);
                        log(`✅ Alternative method worked! Found service: ${ourService.uuid}`);
                    } catch (altError) {
                        log(`❌ Alternative method also failed: ${altError.message}`);
                    }
                }
                log('=== END SERVICE DISCOVERY ===');
                
                log('Getting BLE service...');
                const service = await bleServer.getPrimaryService(BLE_SERVICE_UUID);
                
                // Get characteristics with detailed debugging
                log('Getting control characteristic...');
                controlCharacteristic = await service.getCharacteristic(CONTROL_CHAR_UUID);
                log('✅ Control characteristic obtained');
                
                log('Getting status characteristic...');
                statusCharacteristic = await service.getCharacteristic(STATUS_CHAR_UUID);
                log('✅ Status characteristic obtained');
                
                log('Getting image characteristic...');
                imageCharacteristic = await service.getCharacteristic(IMAGE_CHAR_UUID);
                log('✅ Image characteristic obtained');
                
                log('Getting frame control characteristic...');
                frameControlCharacteristic = await service.getCharacteristic(FRAME_CONTROL_CHAR_UUID);
                log('✅ Frame control characteristic obtained');
                
                log('Getting audio characteristic...');
                audioCharacteristic = await service.getCharacteristic(AUDIO_CHAR_UUID);
                log('✅ Audio characteristic obtained');
                
                // Start notifications with error handling for each characteristic
                try {
                    log('Starting status notifications...');
                    await statusCharacteristic.startNotifications();
                    log('✅ Status notifications started');
                } catch (error) {
                    log('❌ Status notifications failed: ' + error.message);
                }
                
                try {
                    log('Starting image notifications...');
                    await imageCharacteristic.startNotifications();
                    log('✅ Image notifications started');
                } catch (error) {
                    log('❌ Image notifications failed: ' + error.message);
                }
                
                try {
                    log('Starting frame control notifications...');
                    await frameControlCharacteristic.startNotifications();
                    log('✅ Frame control notifications started');
                } catch (error) {
                    log('❌ Frame control notifications failed: ' + error.message);
                }
                
                try {
                    log('Starting audio notifications...');
                    await audioCharacteristic.startNotifications();
                    log('✅ Audio notifications started');
                } catch (error) {
                    log('❌ Audio notifications failed: ' + error.message);
                }
                
                // Add event listeners
                statusCharacteristic.addEventListener('characteristicvaluechanged', handleStatusUpdate);
                imageCharacteristic.addEventListener('characteristicvaluechanged', handleImageData);
                frameControlCharacteristic.addEventListener('characteristicvaluechanged', handleFrameData);
                audioCharacteristic.addEventListener('characteristicvaluechanged', handleBLEAudioData);  // Added BLE audio handler
                
                bleDevice.addEventListener('gattserverdisconnected', handleBLEDisconnection);
                
                isBLEConnected = true;
                updateConnectionStatus();
                enableBLEControls();
                requestStatus();
                
                log('🎉 BLE connected successfully with ultra-speed optimizations!');
                log(`⚡ Ready for 510-byte chunks and maximum throughput`);
                showNotification('Connected to SidekickOS Ultra-Speed via BLE', 'success');
                
            } catch (error) {
                log('BLE connection failed: ' + error.message);
                showNotification('BLE connection failed: ' + error.message, 'error');
                
                // Additional debugging info
                if (error.message.includes('No devices found')) {
                    showNotification('No SidekickOS devices found. Make sure device is powered on and advertising.', 'warning');
                    log('Debug: Check that SidekickOS is powered on, BLE is enabled, and device is advertising');
                    log('Debug: Try restarting the SidekickOS device');
                }
            }
        }

        async function connectBluetoothAudio() {
            // This function is no longer needed since audio is now over BLE
            showNotification('Audio is now streamed over BLE - use Start Audio button', 'warning');
        }

        async function disconnect() {
            if (bleDevice && bleDevice.gatt.connected) {
                bleDevice.gatt.disconnect();
            }
            
            isAudioStreaming = false;
            updateConnectionStatus();
            disableAllControls();
            
            log('BLE device disconnected');
            showNotification('Disconnected from device', 'warning');
        }

        function handleBLEDisconnection() {
            isBLEConnected = false;
            isAudioStreaming = false;
            bleDevice = null;
            bleServer = null;
            controlCharacteristic = null;
            statusCharacteristic = null;
            imageCharacteristic = null;
            frameControlCharacteristic = null;
            audioCharacteristic = null;
            
            updateConnectionStatus();
            disableAllControls();
            log('BLE device disconnected');
            showNotification('BLE device disconnected', 'error');
        }

        function updateConnectionStatus() {
            const bleStatus = document.getElementById('bleStatus');
            const audioStatus = document.getElementById('audioStatus');
            const connectBLEBtn = document.getElementById('connectBLEBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');
            
            // Update BLE status
            if (isBLEConnected) {
                bleStatus.className = 'status-indicator connected';
                bleStatus.innerHTML = '<div class="dot"></div><span>BLE Connected</span>';
                connectBLEBtn.disabled = true;
                disconnectBtn.disabled = false;
            } else {
                bleStatus.className = 'status-indicator disconnected';
                bleStatus.innerHTML = '<div class="dot"></div><span>BLE Disconnected</span>';
                connectBLEBtn.disabled = false;
                disconnectBtn.disabled = true;
            }
            
            // Update Audio status
            if (isAudioStreaming) {
                audioStatus.className = 'status-indicator connected';
                audioStatus.innerHTML = '<div class="dot"></div><span>Audio Streaming</span>';
            } else if (isBLEConnected) {
                audioStatus.className = 'status-indicator partial';
                audioStatus.innerHTML = '<div class="dot"></div><span>Audio Ready</span>';
            } else {
                audioStatus.className = 'status-indicator disconnected';
                audioStatus.innerHTML = '<div class="dot"></div><span>Audio Not Available</span>';
            }
        }

        function enableBLEControls() {
            document.getElementById('startFramesBtn').disabled = false;
            document.getElementById('captureBtn').disabled = false;
            document.getElementById('startAudioBtn').disabled = false;  // Enable audio controls when BLE connects
            document.getElementById('ultraModeBtn').disabled = false;  // Enable ultra mode
        }

        function enableAudioControls() {
            // Audio controls are now enabled with BLE connection
            document.getElementById('audioConnectionStatus').textContent = 'BLE audio ready to stream';
        }

        function disableAllControls() {
            const buttons = ['startFramesBtn', 'stopFramesBtn', 'captureBtn', 'startAudioBtn', 'stopAudioBtn', 'saveFrameBtn', 'ultraModeBtn'];
            buttons.forEach(id => {
                document.getElementById(id).disabled = true;
            });
            
            document.getElementById('audioConnectionStatus').textContent = 'BLE disconnected - audio not available';
            hideAudioVisualizer();
        }

        // Control Functions
        async function sendBLECommand(command) {
            if (!controlCharacteristic) {
                showNotification('BLE not connected', 'error');
                return false;
            }
            
            try {
                const encoder = new TextEncoder();
                await controlCharacteristic.writeValue(encoder.encode(command));
                log('Sent command: ' + command);
                return true;
            } catch (error) {
                log('Failed to send command: ' + error.message);
                showNotification('Failed to send command', 'error');
                return false;
            }
        }

        async function startFrameStream() {
            if (await sendBLECommand('START_FRAMES')) {
                document.getElementById('startFramesBtn').disabled = true;
                document.getElementById('stopFramesBtn').disabled = false;
                document.getElementById('saveFrameBtn').disabled = false;
                log('Frame streaming started');
                showNotification('Frame streaming started', 'success');
            }
        }

        async function stopFrameStream() {
            if (await sendBLECommand('STOP_FRAMES')) {
                document.getElementById('startFramesBtn').disabled = false;
                document.getElementById('stopFramesBtn').disabled = true;
                log('Frame streaming stopped');
                showNotification('Frame streaming stopped', 'success');
            }
        }

        async function captureImage() {
            if (await sendBLECommand('CAPTURE')) {
                log('High-resolution image capture requested');
                showNotification('Capturing high-res image...', 'success');
            }
        }

        async function startAudioStream() {
            if (await sendBLECommand('START_AUDIO')) {
                document.getElementById('startAudioBtn').disabled = true;
                document.getElementById('stopAudioBtn').disabled = false;
                isAudioStreaming = true;
                updateConnectionStatus();
                showAudioVisualizer();
                log('BLE audio streaming started');
                showNotification('BLE audio streaming started', 'success');
            }
        }

        async function stopAudioStream() {
            if (await sendBLECommand('STOP_AUDIO')) {
                document.getElementById('startAudioBtn').disabled = false;
                document.getElementById('stopAudioBtn').disabled = true;
                isAudioStreaming = false;
                
                // Clear audio data to prevent stale audio
                if (audioSource) {
                    audioSource.stop();
                    audioSource = null;
                }
                audioQueue = [];
                isAudioPlaying = false;
                
                updateConnectionStatus();
                hideAudioVisualizer();
                log('BLE audio streaming stopped');
                showNotification('BLE audio streaming stopped', 'success');
            }
        }

        async function updateInterval(value) {
            const floatVal = parseFloat(value);
            const fps = (1 / floatVal).toFixed(1);
            document.getElementById('intervalValue').textContent = `${floatVal.toFixed(2)}s (${fps} FPS)`;
            if (await sendBLECommand(`INTERVAL:${floatVal.toFixed(2)}`)) {
                log(`Frame interval updated: ${floatVal.toFixed(2)} seconds (${fps} FPS)`);
            }
        }

        function togglePerformanceMode(enabled) {
            const intervalSlider = document.getElementById('intervalSlider');
            
            if (enabled) {
                // Set to high performance mode (20 FPS = 0.05s interval)
                intervalSlider.value = "0.05";
                updateInterval(0.05);
                log('High Performance Mode enabled: 20 FPS target');
                showNotification('High Performance Mode: 20 FPS enabled', 'success');
            } else {
                // Reset to default (2 FPS = 0.5s interval)
                intervalSlider.value = "0.5";
                updateInterval(0.5);
                log('High Performance Mode disabled: returning to 2 FPS');
                showNotification('High Performance Mode disabled', 'info');
            }
        }

        let ultraModeActive = false;
        function toggleUltraMode() {
            const intervalSlider = document.getElementById('intervalSlider');
            const ultraBtn = document.getElementById('ultraModeBtn');
            const performanceCheckbox = document.getElementById('performanceMode');
            
            ultraModeActive = !ultraModeActive;
            
            if (ultraModeActive) {
                // ULTRA MODE: 50 FPS = 0.02s interval
                intervalSlider.value = "0.02";
                updateInterval(0.02);
                ultraBtn.textContent = "🔥 ULTRA MODE ACTIVE";
                ultraBtn.style.background = "linear-gradient(45deg, #ff4757, #ff3838)";
                performanceCheckbox.checked = false; // Disable regular performance mode
                log('🔥 ULTRA PERFORMANCE MODE ACTIVATED: 50 FPS TARGET');
                showNotification('🚀 ULTRA MODE: 50 FPS activated!', 'success');
            } else {
                // Return to normal mode
                intervalSlider.value = "0.5";
                updateInterval(0.5);
                ultraBtn.textContent = "🚀 ULTRA MODE (50 FPS)";
                ultraBtn.style.background = "linear-gradient(45deg, #ff6b6b, #feca57)";
                log('⚡ Returning to normal mode: 2 FPS');
                showNotification('Ultra mode disabled', 'info');
            }
        }

        async function updateQuality(value) {
            document.getElementById('qualityValue').textContent = value;
            if (await sendBLECommand(`QUALITY:${value}`)) {
                log(`Image quality updated: ${value}`);
            }
        }

        async function updateFrameSize(value) {
            if (await sendBLECommand(`SIZE:${value}`)) {
                const sizes = ['160x120', '320x240', '352x288', '640x480', '800x600', '1024x768', '1280x720', '1280x1024', '1600x1200'];
                log(`Frame size updated: ${sizes[value]}`);
            }
        }

        function updateVolume(value) {
            document.getElementById('volumeValue').textContent = value + '%';
            // Volume control for local audio playback
        }

        async function requestStatus() {
            await sendBLECommand('STATUS');
        }

        // Data Handlers
        function handleStatusUpdate(event) {
            const decoder = new TextDecoder();
            const statusJson = decoder.decode(event.target.value);
            
            try {
                deviceStatus = JSON.parse(statusJson);
                updateDeviceInfo();
                log('Status updated: ' + statusJson);
            } catch (error) {
                log('Failed to parse status: ' + error.message);
            }
        }

        function updateDeviceInfo() {
            const deviceInfo = document.getElementById('deviceInfo');
            const battery = deviceStatus.battery ? `${deviceStatus.battery}%` : '--';
            const memory = deviceStatus.free_heap ? `${Math.round(deviceStatus.free_heap / 1024)}KB` : '--';
            deviceInfo.innerHTML = `<span>Battery: ${battery} | Memory: ${memory}</span>`;
        }

        function handleImageData(event) {
            handleImageReception(event, false); // Single image capture
        }

        function handleFrameData(event) {
            handleImageReception(event, true); // Frame streaming
        }

        function handleImageReception(event, isFrame) {
            const data = new Uint8Array(event.target.value.buffer);
            
            // Debug all incoming data
            if (data.length > 0) {
                log(`Received ${isFrame ? 'frame' : 'image'} data: ${data.length} bytes, type: 0x${data[0].toString(16).padStart(2, '0')}`);
            }
            
            if (data[0] === 0x01) { // Frame start
                // ESP32 header: [type][chunks_hi][chunks_lo][size_b0][size_b1][size_b2][size_b3]
                const totalChunks = (data[1] << 8) | data[2];
                expectedImageSize = data[3] | (data[4] << 8) | (data[5] << 16) | (data[6] << 24); // Little-endian
                imageBuffer = new Uint8Array(expectedImageSize);
                receivedImageSize = 0;
                receivedChunks = 0;
                expectedChunks = totalChunks;
                isReceivingFrame = isFrame;
                
                showImageProgress();
                log(`Starting ${isFrame ? 'frame' : 'image'} reception: ${expectedImageSize} bytes (${totalChunks} chunks)`);
                
                // Set timeout for image reception
                if (imageTimeout) clearTimeout(imageTimeout);
                imageTimeout = setTimeout(() => {
                    log(`⏰ Image reception timeout! Only received ${receivedChunks}/${expectedChunks} chunks`);
                    hideImageProgress();
                    imageBuffer = null;
                }, 10000); // 10 second timeout
            }
            else if (data[0] === 0x02) { // Data chunk
                if (imageBuffer) {
                    const chunkIndex = (data[1] << 8) | data[2];
                    const chunkData = data.slice(3);
                    
                    // Calculate offset based on chunk index and max chunk size (ESP32 ultra-optimization)
                    const maxChunkSize = 510; // Updated to 510 bytes for BLE 5.0 + DLE optimization
                    const offset = chunkIndex * maxChunkSize;
                    
                    // Debug first few chunks
                    if (receivedChunks < 5) {
                        log(`Chunk ${chunkIndex}: ${chunkData.length} bytes at offset ${offset} (total chunks: ${expectedChunks})`);
                    }
                    
                    // Place chunk data at correct offset
                    if (offset + chunkData.length <= expectedImageSize) {
                        imageBuffer.set(chunkData, offset);
                        receivedChunks++;
                        receivedImageSize += chunkData.length;
                        
                        // Update progress based on chunks received
                        const progress = expectedChunks > 0 ? receivedChunks / expectedChunks : 0;
                        updateImageProgress(progress);
                        
                        if (receivedChunks % 50 === 0 || receivedChunks < 5) {
                            log(`Progress: ${receivedChunks}/${expectedChunks} chunks (${(progress * 100).toFixed(1)}%) - ${receivedImageSize} bytes`);
                        }
                        
                        // Auto-display when all chunks received (fallback if end marker is missing)
                        if (receivedChunks === expectedChunks) {
                            log(`🎯 All chunks received! Auto-displaying without waiting for end marker...`);
                            const trimmedBuffer = imageBuffer.slice(0, receivedImageSize);
                            displayFrame(trimmedBuffer, isReceivingFrame);
                            currentFrame = trimmedBuffer;
                            frameCount++;
                            hideImageProgress();
                            updateFrameInfo(receivedImageSize, isReceivingFrame);
                            
                            // Reset for next image
                            imageBuffer = null;
                            isReceivingFrame = false;
                            receivedImageSize = 0;
                            receivedChunks = 0;
                            expectedChunks = 0;
                            
                            if (imageTimeout) {
                                clearTimeout(imageTimeout);
                                imageTimeout = null;
                            }
                        }
                    } else {
                        log(`❌ Chunk ${chunkIndex} would exceed image bounds (offset: ${offset}, size: ${chunkData.length}, max: ${expectedImageSize})`);
                    }
                }
            }
            else if (data[0] === 0x03) { // Frame complete
                const totalChunks = (data[1] << 8) | data[2];
                
                log(`🏁 Frame completion received: expected ${expectedChunks} chunks, ESP32 reports ${totalChunks} chunks`);
                log(`📊 Reception status: ${receivedChunks}/${expectedChunks} chunks, ${receivedImageSize}/${expectedImageSize} bytes`);
                
                // More lenient completion check - if we have most of the data, try to display it
                const completionThreshold = 0.95; // 95% of chunks received
                const chunksComplete = receivedChunks >= expectedChunks * completionThreshold;
                const sizeReasonable = receivedImageSize > 0 && receivedImageSize <= expectedImageSize * 1.1; // Allow 10% size variation
                
                if (imageBuffer && chunksComplete && sizeReasonable) {
                    log(`✅ Displaying frame: ${receivedImageSize} bytes (${receivedChunks}/${expectedChunks} chunks)`);
                    
                    // Trim imageBuffer to actual received size for proper JPEG processing
                    const trimmedBuffer = imageBuffer.slice(0, receivedImageSize);
                    displayFrame(trimmedBuffer, isReceivingFrame);
                    currentFrame = trimmedBuffer;
                    frameCount++;
                    hideImageProgress();
                    
                    updateFrameInfo(receivedImageSize, isReceivingFrame);
                } else {
                    log(`❌ Frame reception failed - cannot display:`);
                    log(`   Expected: ${expectedImageSize} bytes, ${expectedChunks} chunks`);
                    log(`   Received: ${receivedImageSize} bytes, ${receivedChunks} chunks`);
                    log(`   Checks: buffer=${!!imageBuffer}, chunks=${chunksComplete}, size=${sizeReasonable}`);
                    hideImageProgress();
                }
                
                // Clear timeout and reset for next image
                if (imageTimeout) {
                    clearTimeout(imageTimeout);
                    imageTimeout = null;
                }
                imageBuffer = null;
                isReceivingFrame = false;
                receivedImageSize = 0;
                receivedChunks = 0;
                expectedChunks = 0;
            }
        }

        function displayFrame(imageData, isFrame) {
            try {
                log(`🖼️ Attempting to display ${isFrame ? 'frame' : 'image'}: ${imageData.length} bytes`);
                
                const blob = new Blob([imageData], { type: 'image/jpeg' });
                const url = URL.createObjectURL(blob);
                
                const frameDisplay = document.getElementById('frameDisplay');
                const placeholder = document.getElementById('framePlaceholder');
                
                // Remove existing image
                const existingImg = frameDisplay.querySelector('img');
                if (existingImg) {
                    existingImg.remove();
                }
                
                // Create new image
                const img = document.createElement('img');
                img.src = url;
                img.alt = isFrame ? 'Live frame' : 'Captured image';
                img.style.maxWidth = '100%';
                img.style.height = 'auto';
                
                img.onload = () => {
                    log(`✅ Image loaded successfully: ${img.naturalWidth}x${img.naturalHeight}`);
                    placeholder.style.display = 'none';
                    frameDisplay.appendChild(img);
                    
                    // Clean up URL after a delay
                    setTimeout(() => URL.revokeObjectURL(url), 1000);
                };
                
                img.onerror = (error) => {
                    log(`❌ Image failed to load: ${error}`);
                    log(`   Blob size: ${blob.size} bytes, type: ${blob.type}`);
                    log(`   First few bytes: ${Array.from(imageData.slice(0, 10)).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
                    URL.revokeObjectURL(url);
                };
                
                // Timeout fallback
                setTimeout(() => {
                    if (!img.complete && !img.naturalWidth) {
                        log(`⏰ Image load timeout after 5 seconds`);
                        URL.revokeObjectURL(url);
                    }
                }, 5000);
                
            } catch (error) {
                log(`❌ Error in displayFrame: ${error.message}`);
            }
        }

        function updateFrameInfo(size, isFrame) {
            const frameInfo = document.getElementById('frameInfo');
            const sizeKB = (size / 1024).toFixed(1);
            frameInfo.textContent = `Frame ${frameCount}: ${sizeKB}KB`;
            frameInfo.style.display = 'block';
            
            // Update performance statistics
            updatePerformanceStats('image', size);
            
            currentFrame = imageData;
        }

        function showImageProgress() {
            document.getElementById('imageProgress').style.display = 'block';
            updateImageProgress(0);
        }

        function updateImageProgress(percent) {
            const progressFill = document.getElementById('progressFill');
            progressFill.style.width = (percent * 100) + '%';
        }

        // Simple audio variables
        let audioSource = null;
        let isAudioPlaying = false;

        // BLE Audio Handler - Improved approach to reduce crackling
        function handleBLEAudioData(event) {
            if (!audioContext) return;
            
            const data = new Uint8Array(event.target.value.buffer);
            
            if (data.length === 0) return;
            
            try {
                // Decode μ-law to PCM immediately
                const floatData = new Float32Array(data.length);
                for (let i = 0; i < data.length; i++) {
                    const pcm_sample = mulaw_decode(data[i]);
                    floatData[i] = pcm_sample / 32768.0; // Convert to -1.0 to 1.0 range
                }
                
                if (data.length % 100 === 0) { // Log occasionally
                    console.log('Decoded μ-law audio:', data.length, 'bytes →', floatData.length, 'samples');
                }
                
                // Update performance statistics
                updatePerformanceStats('audio', data.length);
                
                // Add to queue instead of accumulating
                audioQueue.push(floatData);
                
                // Process queue when we have data and audio isn't currently playing
                if (audioQueue.length > 0 && !isAudioPlaying) {
                    processAudioQueue();
                }
                
                // Update visualizer
                visualizeAudio(floatData);
                
            } catch (error) {
                console.error('Audio processing error:', error);
            }
        }

        function processAudioQueue() {
            if (audioQueue.length === 0 || isAudioPlaying) return;
            
            isAudioPlaying = true;
            
            try {
                // Stop any existing audio
                if (audioSource) {
                    audioSource.stop();
                }
                
                // Take first packet from queue
                const audioData = audioQueue.shift();
                
                // Create buffer directly from packet (no accumulation)
                const buffer = audioContext.createBuffer(1, audioData.length, 8000); // 8kHz sample rate to match ESP32
                buffer.getChannelData(0).set(audioData);
                
                // Create and configure audio source
                audioSource = audioContext.createBufferSource();
                if (!audioGainNode) {
                    audioGainNode = audioContext.createGain();
                    audioGainNode.connect(audioContext.destination);
                }
                
                // Reduce volume to prevent crackling and distortion
                audioGainNode.gain.value = (document.getElementById('volumeSlider') ? document.getElementById('volumeSlider').value / 100 : 0.5) * 0.3; // Further reduced volume
                
                audioSource.buffer = buffer;
                audioSource.connect(audioGainNode);
                
                // Set up end handler
                audioSource.onended = () => {
                    isAudioPlaying = false;
                    // Process next packet if available
                    if (audioQueue.length > 0) {
                        setTimeout(() => processAudioQueue(), 5); // Small delay to prevent overlap
                    }
                };
                
                audioSource.start();
                
            } catch (error) {
                console.error('Audio playback error:', error);
                isAudioPlaying = false;
                // Try to recover by processing next packet
                if (audioQueue.length > 0) {
                    setTimeout(() => processAudioQueue(), 100);
                }
            }
        }

        function hideImageProgress() {
            document.getElementById('imageProgress').style.display = 'none';
        }

        // Audio Functions
        function initializeAudio() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                log('Audio context initialized for BLE audio');
            } catch (error) {
                log('Audio not supported: ' + error.message);
            }
        }

        function createAudioVisualizer() {
            const audioBars = document.getElementById('audioBars');
            audioBars.innerHTML = '';
            
            // Create 32 audio bars
            for (let i = 0; i < 32; i++) {
                const bar = document.createElement('div');
                bar.className = 'audio-bar';
                bar.style.height = '2px';
                audioBars.appendChild(bar);
                audioVisualizerBars.push(bar);
            }
        }

        function showAudioVisualizer() {
            document.getElementById('audioVisualizer').style.display = 'block';
        }

        function hideAudioVisualizer() {
            document.getElementById('audioVisualizer').style.display = 'none';
            // Reset all bars
            audioVisualizerBars.forEach(bar => {
                bar.style.height = '2px';
            });
        }

        function visualizeAudio(audioData) {
            if (!audioVisualizerBars.length) return;
            
            const barCount = audioVisualizerBars.length;
            const samplesPerBar = Math.floor(audioData.length / barCount);
            
            for (let i = 0; i < barCount; i++) {
                let sum = 0;
                const start = i * samplesPerBar;
                const end = start + samplesPerBar;
                
                for (let j = start; j < end && j < audioData.length; j++) {
                    sum += Math.abs(audioData[j]);
                }
                
                const average = sum / samplesPerBar;
                const height = Math.min(80, average * 400);
                audioVisualizerBars[i].style.height = height + 'px';
            }
        }

        // Media Functions
        function saveCurrentFrame() {
            if (!currentFrame) {
                showNotification('No frame to save', 'error');
                return;
            }
            
            const blob = new Blob([currentFrame], { type: 'image/jpeg' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `esp32_frame_${frameCount}_${new Date().getTime()}.jpg`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            URL.revokeObjectURL(url);
            showNotification('Frame saved', 'success');
        }

        function toggleFullscreen() {
            const frameDisplay = document.getElementById('frameDisplay');
            
            if (!document.fullscreenElement) {
                frameDisplay.requestFullscreen().catch(err => {
                    showNotification('Fullscreen not supported', 'error');
                });
            } else {
                document.exitFullscreen();
            }
        }

        // PyScript Integration
        function runPyScript() {
            const code = document.getElementById('pythonCode').value;
            if (!code.trim()) {
                showNotification('Please enter some Python code', 'error');
                return;
            }
            
            try {
                if (typeof document.pyExecuteUserCode === 'function') {
                    document.pyExecuteUserCode(code);
                    log('Executing Python code...');
                    showNotification('Python code executed', 'success');
                } else {
                    showNotification('PyScript not ready yet', 'error');
                }
            } catch (error) {
                log('PyScript error: ' + error.message);
                showNotification('PyScript error: ' + error.message, 'error');
            }
        }

        function saveApp() {
            const name = document.getElementById('appName').value;
            const code = document.getElementById('pythonCode').value;
            
            if (!name.trim() || !code.trim()) {
                showNotification('Please enter app name and code', 'error');
                return;
            }
            
            const app = {
                id: Date.now(),
                name: name.trim(),
                code: code,
                created: new Date().toLocaleDateString()
            };
            
            savedApps.push(app);
            localStorage.setItem('esp32_frame_apps', JSON.stringify(savedApps));
            
            loadSavedApps();
            showNotification('Application saved', 'success');
            
            // Clear form
            document.getElementById('appName').value = '';
            document.getElementById('pythonCode').value = '';
        }

        function loadSavedApps() {
            const appList = document.getElementById('appList');
            appList.innerHTML = '';
            
            savedApps.forEach(app => {
                const appCard = document.createElement('div');
                appCard.className = 'app-card';
                appCard.innerHTML = `
                    <h4>${app.name}</h4>
                    <p>Created: ${app.created}</p>
                    <p>${app.code.substring(0, 100)}${app.code.length > 100 ? '...' : ''}</p>
                    <div class="app-actions">
                        <button class="button" onclick="loadApp(${app.id})">Load</button>
                        <button class="button success" onclick="runApp(${app.id})">Run</button>
                        <button class="button danger" onclick="deleteApp(${app.id})">Delete</button>
                    </div>
                `;
                appList.appendChild(appCard);
            });
        }

        function loadApp(id) {
            const app = savedApps.find(a => a.id === id);
            if (app) {
                document.getElementById('appName').value = app.name;
                document.getElementById('pythonCode').value = app.code;
                showNotification('Application loaded', 'success');
            }
        }

        function runApp(id) {
            const app = savedApps.find(a => a.id === id);
            if (app) {
                document.getElementById('pythonCode').value = app.code;
                runPyScript();
            }
        }

        function deleteApp(id) {
            if (confirm('Are you sure you want to delete this application?')) {
                savedApps = savedApps.filter(a => a.id !== id);
                localStorage.setItem('esp32_frame_apps', JSON.stringify(savedApps));
                loadSavedApps();
                showNotification('Application deleted', 'success');
            }
        }

        function clearCode() {
            document.getElementById('pythonCode').value = '';
            document.getElementById('appName').value = '';
        }

        // ESP32 API for PyScript
        window.esp32_api = {
            captureImage: async () => {
                return await sendBLECommand('CAPTURE');
            },
            startFrameStream: async () => {
                return await sendBLECommand('START_FRAMES');
            },
            stopFrameStream: async () => {
                return await sendBLECommand('STOP_FRAMES');
            },
            setInterval: async (seconds) => {
                return await sendBLECommand(`INTERVAL:${seconds}`);
            },
            setQuality: async (value) => {
                return await sendBLECommand(`QUALITY:${value}`);
            },
            startAudioStream: async () => {
                return await sendBLECommand('START_AUDIO');
            },
            stopAudioStream: async () => {
                return await sendBLECommand('STOP_AUDIO');
            },
            getStatus: async () => {
                await sendBLECommand('STATUS');
                return deviceStatus;
            }
        };

        // Utility Functions
        function log(message) {
            const logContainer = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.textContent = `[${timestamp}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // Keep only last 50 log entries
            const entries = logContainer.children;
            while (entries.length > 52) { // 50 + header + ready message
                logContainer.removeChild(entries[2]); // Keep first 2 entries
            }
        }

        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type} show`;
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 4000);
        }

        // Auto-reconnect functionality
        setInterval(() => {
            if (isBLEConnected && (!bleDevice || !bleDevice.gatt.connected)) {
                handleBLEDisconnection();
            }
        }, 5000);

        // Performance monitoring variables
        let performanceStats = {
            imageBytes: 0,
            audioBytes: 0,
            imagePackets: 0,
            audioPackets: 0,
            lastStatsTime: Date.now(),
            currentImageKbps: 0,
            currentAudioKbps: 0,
            averageImageKbps: 0,
            averageAudioKbps: 0,
            frameCount: 0,
            actualFPS: 0,
            lastFrameTime: Date.now()
        };

        // Update performance stats
        function updatePerformanceStats(type, bytes) {
            const now = Date.now();
            const timeDiff = (now - performanceStats.lastStatsTime) / 1000; // seconds
            
            if (type === 'image') {
                performanceStats.imageBytes += bytes;
                performanceStats.imagePackets++;
                performanceStats.frameCount++;
                
                // Calculate FPS
                const frameTimeDiff = (now - performanceStats.lastFrameTime) / 1000;
                if (frameTimeDiff > 0) {
                    performanceStats.actualFPS = 1 / frameTimeDiff;
                }
                performanceStats.lastFrameTime = now;
            } else if (type === 'audio') {
                performanceStats.audioBytes += bytes;
                performanceStats.audioPackets++;
            }
            
            // Update stats every second
            if (timeDiff >= 1.0) {
                performanceStats.currentImageKbps = (performanceStats.imageBytes * 8) / (timeDiff * 1000);
                performanceStats.currentAudioKbps = (performanceStats.audioBytes * 8) / (timeDiff * 1000);
                
                // Calculate running averages
                performanceStats.averageImageKbps = performanceStats.averageImageKbps * 0.8 + performanceStats.currentImageKbps * 0.2;
                performanceStats.averageAudioKbps = performanceStats.averageAudioKbps * 0.8 + performanceStats.currentAudioKbps * 0.2;
                
                // Update UI
                updatePerformanceDisplay();
                
                // Reset counters
                performanceStats.imageBytes = 0;
                performanceStats.audioBytes = 0;
                performanceStats.imagePackets = 0;
                performanceStats.audioPackets = 0;
                performanceStats.lastStatsTime = now;
            }
        }

        function updatePerformanceDisplay() {
            const perfDisplay = document.getElementById('performanceStats');
            if (perfDisplay) {
                perfDisplay.innerHTML = `
                    <div class="perf-row">
                        <span>Image: ${performanceStats.currentImageKbps.toFixed(1)} kbps</span>
                        <span>Audio: ${performanceStats.currentAudioKbps.toFixed(1)} kbps</span>
                    </div>
                    <div class="perf-row">
                        <span>Avg Image: ${performanceStats.averageImageKbps.toFixed(1)} kbps</span>
                        <span>FPS: ${performanceStats.actualFPS.toFixed(1)}</span>
                    </div>
                    <div class="perf-row">
                        <span>Total: ${(performanceStats.currentImageKbps + performanceStats.currentAudioKbps).toFixed(1)} kbps</span>
                        <span>Frames: ${performanceStats.frameCount}</span>
                    </div>
                `;
            }
        }
    </script>
</body>
</html>